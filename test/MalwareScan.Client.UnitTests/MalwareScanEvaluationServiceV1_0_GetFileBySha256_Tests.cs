using System;
using System.IO;
using System.Net;
using System.Net.Http;
using System.Security.Cryptography;
using System.Text;
using System.Threading.Tasks;
using FluentAssertions;
using Microsoft.VisualStudio.TestTools.UnitTesting;
using Moq;

namespace MalwareScan.Client.UnitTests
{
	[TestClass]
	public class MalwareScanEvaluationServiceV1_0_GetFileBySha256Async_Tests : EvaluationServiceTestsBase
	{
		[TestMethod]
		public void GetFileBySha256Async_Throws_ArgumentNullException_Given_NullHash()
		{
			#region Arrange

			var evaluationService = new MalwareScanEvaluationServiceV1_0(ServiceUrl);

			string hash = null;

			#endregion

			#region Act

			Func<Task> action = async () => await evaluationService.GetFileBySha256Async(hash);

			#endregion

			#region Assert

			action.Should().ThrowExactly<ArgumentNullException>("the hash should not be null")
				.Which.ParamName.Should().Be("hash", "because the hash is null");

			#endregion
		}

		[TestMethod]
		public void GetFileBySha256Async_Throws_DummyException_Given_DummyException_In_HttpClient()
		{
			#region Arrange

			string hash = GenerateSha256Hash();

			var mockRepo = new MockRepository(MockBehavior.Strict);

			HttpMessageHandler handler = CreateHttpMessageHandler(mockRepo,
				x => x.Method.Method == "GET" && x.RequestUri.ToString() == $"{ServiceUrl}eval/file/sha256/{hash}",
				new DummyException("Unhandled exception during a mocked HTTP call."));

			var httpClient = new HttpClient(handler);

			var evaluationService = new MalwareScanEvaluationServiceV1_0(ServiceUrl, httpClient);

			#endregion

			#region Act

			Func<Task<EvaluationFile>> action = async () => await evaluationService.GetFileBySha256Async(hash);

			#endregion

			#region Assert

			action.Should().ThrowExactly<DummyException>("the HTTP client throws a dummy exception");

			#endregion
		}

		[TestMethod]
		public void GetFileBySha256Async_Throws_EvaluationFileNotFoundException_Given_NotFound()
		{
			#region Arrange

			string hash = GenerateSha256Hash();

			var mockRepo = new MockRepository(MockBehavior.Strict);

			HttpMessageHandler handler = CreateHttpMessageHandler(mockRepo,
				x => x.Method.Method == "GET" && x.RequestUri.ToString() == $"{ServiceUrl}eval/file/sha256/{hash}",
				HttpStatusCode.NotFound);

			var httpClient = new HttpClient(handler);

			var evaluationService = new MalwareScanEvaluationServiceV1_0(ServiceUrl, httpClient);

			#endregion

			#region Act

			Func<Task<EvaluationFile>> action = async () => await evaluationService.GetFileBySha256Async(hash);

			#endregion

			#region Assert

			action.Should().ThrowExactly<EvaluationFileNotFoundException>("the HTTP client returns 404 Not Found");

			#endregion
		}

		[TestMethod]
		public void GetFileBySha256Async_Throws_AuthenticationException_Given_Unauthorized()
		{
			#region Arrange

			string hash = GenerateSha256Hash();

			var mockRepo = new MockRepository(MockBehavior.Strict);

			HttpMessageHandler handler = CreateHttpMessageHandler(mockRepo,
				x => x.Method.Method == "GET" && x.RequestUri.ToString() == $"{ServiceUrl}eval/file/sha256/{hash}",
				HttpStatusCode.Unauthorized);

			var httpClient = new HttpClient(handler);

			var evaluationService = new MalwareScanEvaluationServiceV1_0(ServiceUrl, httpClient);

			#endregion

			#region Act

			Func<Task<EvaluationFile>> action = async () => await evaluationService.GetFileBySha256Async(hash);

			#endregion

			#region Assert

			action.Should().ThrowExactly<AuthenticationException>("the HTTP client returns 401 Unauthorized");

			#endregion
		}

		[TestMethod]
		public void GetFileBySha256Async_Throws_AuthorizationException_Given_Forbidden()
		{
			#region Arrange

			string hash = GenerateSha256Hash();

			var mockRepo = new MockRepository(MockBehavior.Strict);

			HttpMessageHandler handler = CreateHttpMessageHandler(mockRepo,
				x => x.Method.Method == "GET" && x.RequestUri.ToString() == $"{ServiceUrl}eval/file/sha256/{hash}",
				HttpStatusCode.Forbidden);

			var httpClient = new HttpClient(handler);

			var evaluationService = new MalwareScanEvaluationServiceV1_0(ServiceUrl, httpClient);

			#endregion

			#region Act

			Func<Task<EvaluationFile>> action = async () => await evaluationService.GetFileBySha256Async(hash);

			#endregion

			#region Assert

			action.Should().ThrowExactly<AuthorizationException>("the HTTP client returns 403 Forbidden");

			#endregion
		}

		[TestMethod]
		public void GetFileBySha256Async_Throws_EvaluationServiceException_Given_InternalServerError()
		{
			#region Arrange

			string hash = GenerateSha256Hash();

			var mockRepo = new MockRepository(MockBehavior.Strict);

			HttpMessageHandler handler = CreateHttpMessageHandler(mockRepo,
				x => x.Method.Method == "GET" && x.RequestUri.ToString() == $"{ServiceUrl}eval/file/sha256/{hash}",
				HttpStatusCode.InternalServerError);

			var httpClient = new HttpClient(handler);

			var evaluationService = new MalwareScanEvaluationServiceV1_0(ServiceUrl, httpClient);

			#endregion

			#region Act

			Func<Task<EvaluationFile>> action = async () => await evaluationService.GetFileBySha256Async(hash);

			#endregion

			#region Assert

			action.Should().ThrowExactly<EvaluationServiceException>("the HTTP client returns 500 Internal Server Error");

			#endregion
		}

		[TestMethod]
		public void GetFileBySha256Async_Throws_EvaluationServiceException_Given_UnexpectedResponse()
		{
			#region Arrange

			string hash = GenerateSha256Hash();

			var mockRepo = new MockRepository(MockBehavior.Strict);

			HttpMessageHandler handler = CreateHttpMessageHandler(mockRepo,
				x => x.Method.Method == "GET" && x.RequestUri.ToString() == $"{ServiceUrl}eval/file/sha256/{hash}",
				0);

			var httpClient = new HttpClient(handler);

			var evaluationService = new MalwareScanEvaluationServiceV1_0(ServiceUrl, httpClient);

			#endregion

			#region Act

			Func<Task<EvaluationFile>> action = async () => await evaluationService.GetFileBySha256Async(hash);

			#endregion

			#region Assert

			action.Should().ThrowExactly<EvaluationServiceException>("the HTTP client returns unexpected status code");

			#endregion
		}

		// TODO: test with files and different statuses
		[TestMethod]
		[DataRow("D8A928B2043DB77E340B523547BF16CB4AA483F0645FE0A290ED1F20AAB76257", null, null, null)]
		[DataRow("D8A928B2043DB77E340B523547BF16CB4AA483F0645FE0A290ED1F20AAB76257", null, null, false)]
		[DataRow("D8A928B2043DB77E340B523547BF16CB4AA483F0645FE0A290ED1F20AAB76257", null, null, true)]
		[DataRow("D8A928B2043DB77E340B523547BF16CB4AA483F0645FE0A290ED1F20AAB76257", null, "Message", null)]
		[DataRow("D8A928B2043DB77E340B523547BF16CB4AA483F0645FE0A290ED1F20AAB76257", null, "Message", false)]
		[DataRow("D8A928B2043DB77E340B523547BF16CB4AA483F0645FE0A290ED1F20AAB76257", null, "Message", true)]
		[DataRow("D8A928B2043DB77E340B523547BF16CB4AA483F0645FE0A290ED1F20AAB76257", "file.pdf", null, null)]
		[DataRow("D8A928B2043DB77E340B523547BF16CB4AA483F0645FE0A290ED1F20AAB76257", "file.pdf", null, false)]
		[DataRow("D8A928B2043DB77E340B523547BF16CB4AA483F0645FE0A290ED1F20AAB76257", "file.pdf", null, true)]
		[DataRow("D8A928B2043DB77E340B523547BF16CB4AA483F0645FE0A290ED1F20AAB76257", "file.pdf", "Message", null)]
		[DataRow("D8A928B2043DB77E340B523547BF16CB4AA483F0645FE0A290ED1F20AAB76257", "file.pdf", "Message", false)]
		[DataRow("D8A928B2043DB77E340B523547BF16CB4AA483F0645FE0A290ED1F20AAB76257", "file.pdf", "Message", true)]
		public async Task GetFileBySha256Async_Returns_Evaluation(string sha256, string fileName, string message, bool? isMalicious)
		{
			#region Arrange

			DateTime statusDate = DateTime.Now;

			var mockRepo = new MockRepository(MockBehavior.Strict);

			HttpResponseMessage responseMessage = CreateHttpResponseMessage(sha256,
				fileName,
				message,
				statusDate,
				isMalicious);

			HttpMessageHandler handler = CreateHttpMessageHandler(mockRepo,
				x => x.Method.Method == "GET" && x.RequestUri.ToString() == $"{ServiceUrl}eval/file/sha256/{sha256}",
				responseMessage);

			var httpClient = new HttpClient(handler);

			var evaluationService = new MalwareScanEvaluationServiceV1_0(ServiceUrl, httpClient);

			#endregion

			#region Act

			EvaluationFile result = await evaluationService.GetFileBySha256Async(sha256);

			#endregion

			#region Assert

			result.Should().NotBeNull("the evaluation file should not be null");

			result.FileName.Should().BeEquivalentTo(fileName, "the file name match the expected one");

			result.Sha256.Should().BeEquivalentTo(sha256, "the SHA 256 hash match the expected one");

			// TODO: assert status

			result.StatusDate.Should().Be(statusDate, "the status date should match the expected one");

			result.IsMalicious.Should().Be(isMalicious, "the malicious flag should match the expected one");

			result.Message.Should().BeEquivalentTo(message, "the message should match the expected one");

			#endregion
		}

		private static HttpResponseMessage CreateHttpResponseMessage(string sha256,
			string fileName,
			string message,
			DateTime statusDate,
			bool? isMalicious)
		{
			var result = new MalwareScanApiV1_0.EvaluationFile
			{
				FileName = fileName,
				Sha256 = sha256,
				// TODO: set as argument
				Status = MalwareScanApiV1_0.EvaluationStatus.Complete,
				StatusDate = statusDate,
				Malicious = isMalicious,
				Message = message,
			};

			return CreateHttpResponseMessage(HttpStatusCode.OK, result);
		}

		private static string GenerateSha256Hash()
		{
			string inputString = Guid.NewGuid().ToString();
			byte[] inputBytes = Encoding.UTF8.GetBytes(inputString);

			byte[] hashBytes;

			using (SHA256 hashAlgorithm = SHA256.Create())
			{
				hashBytes = hashAlgorithm.ComputeHash(inputBytes);
			}

			var builder = new StringBuilder();
			for (int i = 0; i < hashBytes.Length; i++)
			{
				builder.Append(hashBytes[i].ToString("x2"));
			}

			return builder.ToString();
		}
	}
}
