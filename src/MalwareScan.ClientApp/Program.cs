using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Net.Http;
using System.Security.Cryptography.X509Certificates;
using System.Threading;
using System.Threading.Tasks;
using CommandLine;
using CLIENT = MalwareScan.Client;

namespace MalwareScan.ClientApp
{
	/// <summary>
	/// Represents the application main class.
	/// </summary>
	internal class Program
	{
		/// <summary>
		/// Entry point for the application
		/// </summary>
		/// <param name="args">application arguments</param>
		/// <returns>a task that represents the asynchronous operation</returns>
		private static async Task<int> Main(string[] args)
		{
			ParserResult<object> result = Parser.Default.ParseArguments<SubmitOptions, GetOptions, GetFileBySha256Options>(args);

			try
			{
				await result.MapResult(
					async (SubmitOptions options) => await SubmitAsync(options),
					async (GetOptions options) => await GetAsync(options),
					async (GetFileBySha256Options options) => await GetFileBySha256Async(options),
					async (IEnumerable<Error> errors) => await HandleErrorsAsync(errors));
			}
			catch (CLIENT.EvaluationServiceException ex)
			{
				await Console.Error.WriteLineAsync($"An error has occurred while calling the Evaluation Service: {ex}");

				return (int)ProgramExitCodes.EvaluationServiceError;
			}
			catch (Exception ex)
			{
				await Console.Error.WriteLineAsync($"An unhandled error has occurred: {ex}");

				return (int)ProgramExitCodes.GenericError;
			}

			return (int)ProgramExitCodes.Ok;
		}

		private static async Task SubmitAsync(SubmitOptions options,
			CancellationToken cancellationToken = default)
		{
			CLIENT.IEvaluationService evaluationService = CreateService(options);

			string correlationID = options.CorrelationID;

			CLIENT.FileParameter[] fileParameters = options.InputFileNames
				.Select(x => new CLIENT.FileParameter
				{
					FileName = x,
				})
				.ToArray();

			string id = await evaluationService.SubmitAsync(fileParameters, correlationID, cancellationToken);

			WriteOutput(id, options.OutputFormat, Console.Out);
		}

		private static async Task GetAsync(GetOptions options,
			CancellationToken cancellationToken = default)
		{
			CLIENT.IEvaluationService evaluationService = CreateService(options);

			CLIENT.Evaluation evaluation = await evaluationService.GetAsync(options.Id, cancellationToken);

			WriteOutput(evaluation, options.OutputFormat, Console.Out);
		}

		private static async Task GetFileBySha256Async(GetFileBySha256Options options,
			CancellationToken cancellationToken = default)
		{
			CLIENT.IEvaluationService evaluationService = CreateService(options);

			CLIENT.EvaluationFile evaluationFile = await evaluationService.GetFileBySha256Async(options.Hash, cancellationToken);

			WriteOutput(evaluationFile, options.OutputFormat, Console.Out);
		}

		private static async Task HandleErrorsAsync(IEnumerable<Error> errors,
			CancellationToken cancellationToken = default)
		{
			foreach (Error error in errors)
			{
				string message = error.ToString();

				await Console.Error.WriteLineAsync(message);
			}
		}

		internal static CLIENT.IEvaluationService CreateService(OptionsBase options)
		{
			if (options == null)
			{
				throw new ArgumentNullException(nameof(options));
			}

			CLIENT.EvaluationServiceType type = GetEvaluationServiceType(options);

			X509Certificate2 clientCertificate = GetCertificate(options);

			HttpClient httpClient = CLIENT.EvaluationServiceFactory.CreateHttpClient(clientCertificate,
				userName: options.UserName,
				password: options.Password,
				serverCertificateCustomValidationCallback: options.NoValidation
					? HttpClientHandler.DangerousAcceptAnyServerCertificateValidator
					: null);

			CLIENT.IEvaluationService evaluationService = CLIENT.EvaluationServiceFactory.CreateEvaluationService(options.Url, httpClient, type);

			return evaluationService;
		}

		private static CLIENT.EvaluationServiceType GetEvaluationServiceType(OptionsBase options)
		{
			CLIENT.EvaluationServiceType type;

			switch (options.ServiceType)
			{
				case ServiceType.MalwareScanV1_0:
					{
						type = CLIENT.EvaluationServiceType.MalwareScanV1_0;
						break;
					}
				case ServiceType.MalwareScanV1_1:
					{
						type = CLIENT.EvaluationServiceType.MalwareScanV1_1;
						break;
					}
				default:
					{
						throw new NotImplementedException($"Service type `{options.ServiceType}` is not implemented yet.");
					}
			}

			return type;
		}

		private static X509Certificate2 GetCertificate(OptionsBase options)
		{
			X509Certificate2 clientCertificate;

			if (options.CertificateFileName != null)
			{
				clientCertificate = new X509Certificate2(options.CertificateFileName, options.CertificatePassword);
			}
			else if (options.CertificateThumbprint != null)
			{
				if (options.CertificateStoreName == null)
				{
					throw new ApplicationException($"A client certificate thumbprint `{options.CertificateThumbprint}` is specified but no store name is provided.");
				}

				using (var store = new X509Store(options.CertificateStoreName))
				{
					store.Open(OpenFlags.ReadOnly | OpenFlags.OpenExistingOnly);

					X509Certificate2Collection clientCertificates = store.Certificates.Find(X509FindType.FindByThumbprint, options.CertificateThumbprint, false);
					if (clientCertificates.Count <= 0)
					{
						throw new ApplicationException($"Could not find a client certificate with thumbprint `{options.CertificateThumbprint}` in the `{options.CertificateStoreName}` store.");
					}

					clientCertificate = clientCertificates[0];
				}
			}
			else
			{
				clientCertificate = null;
			}

			return clientCertificate;
		}

		private static void WriteOutput(object value, OutputFormat format, TextWriter writer)
		{
			switch (format)
			{
				case OutputFormat.Yaml:
					{
						var serializer = new YamlDotNet.Serialization.Serializer();

						serializer.Serialize(writer, value);
						break;
					}
				case OutputFormat.Json:
					{
						var serializer = new Newtonsoft.Json.JsonSerializer
						{
							Formatting = Newtonsoft.Json.Formatting.Indented,
						};

						serializer.Serialize(writer, value);
						break;
					}
				default:
					{
						throw new NotSupportedException($"Output format `{format}` is not supported in this context.");
					}
			}
		}
	}
}
